<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title></title><meta content="" name="description"/><meta content="" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../lib/jquery.js"></script><script type="text/javascript" src="../lib/index.js"></script><script type="text/javascript" src="../index.js"></script><script type="text/javascript" src="../lib/scheduler.js"></script><script type="text/javascript" src="../lib/template.js"></script><script type="text/javascript" src="../lib/tools.tooltip.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../';</script></head><body><div id="search"><span id="doc-title"><span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="index.html#_root_" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.daut" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="daut"></a><a id="daut:daut"></a> <span class="permalink"><a href="index.html#daut" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title="Daut (Data automata) is an internal Scala DSL for writing event stream monitors."><span class="name">daut</span></a></span><p class="shortcomment cmt">Daut (Data automata) is an internal Scala DSL for writing event stream monitors.</p><div class="fullcomment"><div class="comment cmt"><p>Daut (Data automata) is an internal Scala DSL for writing event stream monitors. It
supports flavors of state machines, temporal logic, and rule-based programming, all in one
unified formalism. The underlying concept is that at any point during monitoring there is an
active set of states, the _state soup_. States can be added and removed from this soup.
Each state in the soup either monitors the incoming event stream, or is used by other states to record
data (as in rule-based programming).</p><p>The specification language specifically supports:</p><ul><li>Automata, represented by states, parameterized with data (thereby the name Daut: Data automata).</li><li>Temporal operators which generate states, resulting in more succinct specifications.</li><li>Rule-based programming in that one can test for the presence of states and one can add states.</li><li>General purpose programming in Scala when the other specification features fall short.</li></ul><p>The DSL is a simplification of the TraceContract (<a href="https://github.com/havelund/tracecontract" target="_blank">https://github.com/havelund/tracecontract</a>) internal Scala DSL by an order of magnitude less code.</p><p>The general idea is to create a monitor as a class sub-classing the <code>Monitor</code> class,
create an instance of it, and then feed it with events with the <code>verify(event: Event)</code> method,
one by one, and in the case of a finite sequence of observations, finally calling the
<code>end()</code> method on it. If <code>end()</code> is called, it will be determined whether
there are any outstanding obligations that have not been satisfied (expected events that did not occur).</p><p>This can schematically be illustrated as follows:</p><pre><span class="kw">class</span> MyMonitor <span class="kw">extends</span> Monitor[SomeType] {
...
}

<span class="kw">object</span> Main {
  <span class="kw">def</span> main(args: <span class="std">Array</span>[<span class="std">String</span>]) {
    <span class="kw">val</span> m = <span class="kw">new</span> MyMonitor()
    m.verify(event1)
    m.verify(event2)
    ...
    m.verify(eventN)
    m.end()
  }
}</pre></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="daut.Monitor" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Monitor[E]extendsAnyRef"></a><a id="Monitor[E]:Monitor[E]"></a> <span class="permalink"><a href="../daut/index.html#Monitor[E]extendsAnyRef" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="Monitor.html" title="Any monitor must sub-class this class."><span class="name">Monitor</span></a><span class="tparams">[<span name="E">E</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Any monitor must sub-class this class.</p><div class="fullcomment"><div class="comment cmt"><p>Any monitor must sub-class this class. It provides all the DSL constructs for writing
a monitor.
</p></div><dl class="paramcmts block"><dt class="tparam">E</dt><dd class="cmt"><p>the type of events submitted to the monitor.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="daut" id="daut" class="extype">daut</a></dd></dl></div></li><li class="current-entities indented2"><span class="separator"></span> <a href="Monitor$anonymous.html" title="An anonymous state can be labelled with data with a call of the label method." class="trait"></a><a href="Monitor$anonymous.html" title="An anonymous state can be labelled with data with a call of the label method.">anonymous</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Monitor$during.html" title="The state is usually assigned to a local val-variable that can be queried e.g." class="class"></a><a href="Monitor$during.html" title="The state is usually assigned to a local val-variable that can be queried e.g.">during</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Monitor$error$.html" title="Special state indicating a specification violation." class="object"></a><a href="Monitor$error$.html" title="Special state indicating a specification violation.">error</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="" title="A subtrait of the state trait." class="trait"></a><a href="" title="A subtrait of the state trait.">fact</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Monitor$ok$.html" title="Special state indicating successful termination." class="object"></a><a href="Monitor$ok$.html" title="Special state indicating successful termination.">ok</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Monitor$state.html" title="A state of the monitor." class="trait"></a><a href="Monitor$state.html" title="A state of the monitor.">state</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="Monitor$stay$.html" title="Special state indicating that we stay in the current state." class="object"></a><a href="Monitor$stay$.html" title="Special state indicating that we stay in the current state.">stay</a></li></ul></div></div><div id="content"><body class="trait type"><div id="definition"><div class="big-circle trait">t</div><p id="owner"><a href="index.html" name="daut" id="daut" class="extype">daut</a>.<a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></p><h1>fact<span class="permalink"><a href="../daut/Monitor$fact.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><span class="name">fact</span><span class="result"> extends <a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a></span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>A subtrait of the <code>state</code> trait. Named states introduced by the user as case classes are called
facts and must extend this trait, as in:</p><pre><span class="kw">case</span> <span class="kw">class</span> MyData(x:<span class="std">Int</span>) <span class="kw">extends</span> fact</pre><p>The <code>toString</code> method works as for case classes.
</p></div><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a>, <span name="scala.AnyRef" class="extype">AnyRef</span>, <span name="scala.Any" class="extype">Any</span></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="daut.Monitor.fact"><span>fact</span></li><li class="in" name="daut.Monitor.state"><span>state</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##():Int"></a> <span class="permalink"><a href="../daut/Monitor$fact.html###():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="daut.Monitor.state#always" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="always(ts:Monitor.this.Transitions):Monitor.this.state"></a><a id="always(Transitions):state"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#always(ts:Monitor.this.Transitions):Monitor.this.state" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">always</span><span class="params">(<span name="ts">ts: <a href="Monitor.html#Transitions=PartialFunction[E,Set[Monitor.this.state]]" name="daut.Monitor.Transitions" id="daut.Monitor.Transitions" class="extmbr">Transitions</a></span>)</span><span class="result">: <a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a></span></span><p class="shortcomment cmt">Updates the transition function to the transition function provided,
modified to always include the state in the resulting state set of any transition.</p><div class="fullcomment"><div class="comment cmt"><p>Updates the transition function to the transition function provided,
modified to always include the state in the resulting state set of any transition.
This corresponds to a state where the monitor is always waiting  until an event
is submitted that makes a transition fire, and where the state has a true
self loop, no matter what transition fires. The state is final.
If the state has already been initialized with a transition function it calls the
corresponding function in the monitor, which returns a new state.
</p></div><dl class="paramcmts block"><dt class="param">ts</dt><dd class="cmt"><p>the transition function.</p></dd><dt>returns</dt><dd class="cmt"><p>the state itself, allowing for further chained method calls.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor.state#apply" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="apply(event:E):Option[Set[Monitor.this.state]]"></a><a id="apply(E):Option[Set[state]]"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#apply(event:E):Option[Set[Monitor.this.state]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">apply</span><span class="params">(<span name="event">event: <span name="daut.Monitor.E" class="extype">E</span></span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Predef.Set" class="extype">Set</span>[<a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a>]]</span></span><p class="shortcomment cmt">Applies the state to an event.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the state to an event. If the transition function associated with the state
can fire, the resulting state set <code>ss</code> is returned as <code>Some(ss)</code>.
If the transition function cannot fire <code>None</code> is returned.
</p></div><dl class="paramcmts block"><dt class="param">event</dt><dd class="cmt"><p>the event the state is applied to.</p></dd><dt>returns</dt><dd class="cmt"><p>the optional set of states resulting from taking a transition.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a></dd></dl></div></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object"></a><a id="clone():AnyRef"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<a href="../java/lang/index.html" name="java.lang" id="java.lang" class="extype">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#equals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="equals(x$1:Object):Boolean"></a><a id="equals(AnyRef):Boolean"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#equals(x$1:Object):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<a href="../java/lang/index.html" name="java.lang" id="java.lang" class="extype">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]"></a><a id="getClass():Class[_&lt;:AnyRef]"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <span name="java.lang.Class" class="extype">Class</span>[_ &lt;: <span name="scala.AnyRef" class="extype">AnyRef</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#hashCode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hashCode():Int"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#hashCode():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="daut.Monitor.state#hot" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hot(ts:Monitor.this.Transitions):Monitor.this.state"></a><a id="hot(Transitions):state"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#hot(ts:Monitor.this.Transitions):Monitor.this.state" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hot</span><span class="params">(<span name="ts">ts: <a href="Monitor.html#Transitions=PartialFunction[E,Set[Monitor.this.state]]" name="daut.Monitor.Transitions" id="daut.Monitor.Transitions" class="extmbr">Transitions</a></span>)</span><span class="result">: <a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a></span></span><p class="shortcomment cmt">Updates the transition function to the transition function provided.</p><div class="fullcomment"><div class="comment cmt"><p>Updates the transition function to the transition function provided.
This corresponds to a state where the monitor is just waiting (watching) until an event
is submitted that makes a transition fire. The state is non-final, meaning
that it is an error to be in this state on a call of the <code>end()</code> method.
If the state has already been initialized with a transition function it calls the
corresponding function in the monitor, which returns a new state.
</p></div><dl class="paramcmts block"><dt class="param">ts</dt><dd class="cmt"><p>the transition function.</p></dd><dt>returns</dt><dd class="cmt"><p>the state itself, allowing for further chained method calls.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a></dd></dl></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="daut.Monitor.state#name" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="name:String"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#name:String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">name</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><p class="shortcomment cmt">String used to print state when not a case class.</p><div class="fullcomment"><div class="comment cmt"><p>String used to print state when not a case class. Used for anonymous states.
</p></div><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="daut.Monitor.state#next" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="next(ts:Monitor.this.Transitions):Monitor.this.state"></a><a id="next(Transitions):state"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#next(ts:Monitor.this.Transitions):Monitor.this.state" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">next</span><span class="params">(<span name="ts">ts: <a href="Monitor.html#Transitions=PartialFunction[E,Set[Monitor.this.state]]" name="daut.Monitor.Transitions" id="daut.Monitor.Transitions" class="extmbr">Transitions</a></span>)</span><span class="result">: <a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a></span></span><p class="shortcomment cmt">Updates the transition function to the transition function provided,
modified to yield an error if it does not fire on the next submitted event.</p><div class="fullcomment"><div class="comment cmt"><p>Updates the transition function to the transition function provided,
modified to yield an error if it does not fire on the next submitted event.
The transition is strong in the sense that a next event has to occur.
The state is therefore non-final.
If the state has already been initialized with a transition function it calls the
corresponding function in the monitor, which returns a new state.
</p></div><dl class="paramcmts block"><dt class="param">ts</dt><dd class="cmt"><p>the transition function.</p></dd><dt>returns</dt><dd class="cmt"><p>the state itself, allowing for further chained method calls.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](=&gt;T0):T0"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <span name="java.lang.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="daut.Monitor.state#unless" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="unless(ts1:Monitor.this.Transitions):AnyRef{defwatch(ts2:Monitor.this.Transitions):Monitor.this.state}"></a><a id="unless(Transitions):AnyRef{defwatch(ts2:Monitor.this.Transitions):Monitor.this.state}"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#unless(ts1:Monitor.this.Transitions):AnyRef{defwatch(ts2:Monitor.this.Transitions):Monitor.this.state}" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">unless</span><span class="params">(<span name="ts1">ts1: <a href="Monitor.html#Transitions=PartialFunction[E,Set[Monitor.this.state]]" name="daut.Monitor.Transitions" id="daut.Monitor.Transitions" class="extmbr">Transitions</a></span>)</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span> { def watch(ts2: Monitor.this.Transitions): Monitor.this.state }</span></span><p class="shortcomment cmt">An expression of the form <code>unless {ts1} watch {ts2</code>} watches <code>ts2</code> repeatedly
unless <code>ts1</code> fires.</p><div class="fullcomment"><div class="comment cmt"><p>An expression of the form <code>unless {ts1} watch {ts2</code>} watches <code>ts2</code> repeatedly
unless <code>ts1</code> fires. That is, the expression updates the transition function as
the combination of the two transition functions provided. The resulting transition function
first tries <code>ts1</code>, and if it can fire that is chosen. Otherwise <code>t2</code> is tried,
and if it can fire it is made to fire, and the unless-state is re-added to the resulting state set.
The transition function <code>ts1</code> does not need to ever fire, which makes the state final.
If the state has already been initialized with a transition function it calls the
corresponding function in the monitor, which returns a new state.
</p></div><dl class="paramcmts block"><dt class="param">ts1</dt><dd class="cmt"><p>the transition function.</p></dd><dt>returns</dt><dd class="cmt"><p>the state itself, allowing for further chained method calls.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor.state#until" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="until(ts1:Monitor.this.Transitions):AnyRef{defwatch(ts2:Monitor.this.Transitions):Monitor.this.state}"></a><a id="until(Transitions):AnyRef{defwatch(ts2:Monitor.this.Transitions):Monitor.this.state}"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#until(ts1:Monitor.this.Transitions):AnyRef{defwatch(ts2:Monitor.this.Transitions):Monitor.this.state}" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">until</span><span class="params">(<span name="ts1">ts1: <a href="Monitor.html#Transitions=PartialFunction[E,Set[Monitor.this.state]]" name="daut.Monitor.Transitions" id="daut.Monitor.Transitions" class="extmbr">Transitions</a></span>)</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span> { def watch(ts2: Monitor.this.Transitions): Monitor.this.state }</span></span><p class="shortcomment cmt">An expression of the form <code>until {ts1} watch {ts2</code>} watches <code>ts2</code> repeatedly
until <code>ts1</code> fires.</p><div class="fullcomment"><div class="comment cmt"><p>An expression of the form <code>until {ts1} watch {ts2</code>} watches <code>ts2</code> repeatedly
until <code>ts1</code> fires. That is, the expression updates the transition function as
the combination of the two transition functions provided. The resulting transition function
first tries <code>ts1</code>, and if it can fire that is chosen. Otherwise <code>t2</code> is tried,
and if it can fire it is made to fire, and the unless-state is re-added to the resulting state set.
The transition function <code>ts1</code> will need to eventually ever fire before <code>end()</code> is
called, which makes the state non-final.
If the state has already been initialized with a transition function it calls the
corresponding function in the monitor, which returns a new state.
</p></div><dl class="paramcmts block"><dt class="param">ts1</dt><dd class="cmt"><p>the transition function.</p></dd><dt>returns</dt><dd class="cmt"><p>the state itself, allowing for further chained method calls.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="daut.Monitor.state#watch" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="watch(ts:Monitor.this.Transitions):Monitor.this.state"></a><a id="watch(Transitions):state"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#watch(ts:Monitor.this.Transitions):Monitor.this.state" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">watch</span><span class="params">(<span name="ts">ts: <a href="Monitor.html#Transitions=PartialFunction[E,Set[Monitor.this.state]]" name="daut.Monitor.Transitions" id="daut.Monitor.Transitions" class="extmbr">Transitions</a></span>)</span><span class="result">: <a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a></span></span><p class="shortcomment cmt">Updates the transition function to exactly the transition function provided.</p><div class="fullcomment"><div class="comment cmt"><p>Updates the transition function to exactly the transition function provided.
This corresponds to a state where the monitor is just waiting (watching) until an event
is submitted that makes a transition fire. The state is final.
If the state has already been initialized with a transition function it calls the
corresponding function in the monitor, which returns a new state.
</p></div><dl class="paramcmts block"><dt class="param">ts</dt><dd class="cmt"><p>the transition function.</p></dd><dt>returns</dt><dd class="cmt"><p>the state itself, allowing for further chained method calls.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor.state#wnext" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wnext(ts:Monitor.this.Transitions):Monitor.this.state"></a><a id="wnext(Transitions):state"></a> <span class="permalink"><a href="../daut/Monitor$fact.html#wnext(ts:Monitor.this.Transitions):Monitor.this.state" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wnext</span><span class="params">(<span name="ts">ts: <a href="Monitor.html#Transitions=PartialFunction[E,Set[Monitor.this.state]]" name="daut.Monitor.Transitions" id="daut.Monitor.Transitions" class="extmbr">Transitions</a></span>)</span><span class="result">: <a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a></span></span><p class="shortcomment cmt">Updates the transition function to the transition function provided,
modified to yield an error if it does not fire on the next submitted event.</p><div class="fullcomment"><div class="comment cmt"><p>Updates the transition function to the transition function provided,
modified to yield an error if it does not fire on the next submitted event.
The transition is weak in the sense that a next event does not have to occur (in contrast to strong next).
The state is therefore final.
If the state has already been initialized with a transition function it calls the
corresponding function in the monitor, which returns a new state.
</p></div><dl class="paramcmts block"><dt class="param">ts</dt><dd class="cmt"><p>the transition function.</p></dd><dt>returns</dt><dd class="cmt"><p>the state itself, allowing for further chained method calls.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a></dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="daut.Monitor.state" class="parent"><h3>Inherited from <a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a></h3></div><div name="scala.AnyRef" class="parent"><h3>Inherited from <span name="scala.AnyRef" class="extype">AnyRef</span></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
