<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title></title><meta content="" name="description"/><meta content="" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../lib/jquery.js"></script><script type="text/javascript" src="../lib/index.js"></script><script type="text/javascript" src="../index.js"></script><script type="text/javascript" src="../lib/scheduler.js"></script><script type="text/javascript" src="../lib/template.js"></script><script type="text/javascript" src="../lib/tools.tooltip.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../';</script></head><body><div id="search"><span id="doc-title"><span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="index.html#_root_" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.daut" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="daut"></a><a id="daut:daut"></a> <span class="permalink"><a href="index.html#daut" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title="Daut (Data automata) is an internal Scala DSL for writing event stream monitors."><span class="name">daut</span></a></span><p class="shortcomment cmt">Daut (Data automata) is an internal Scala DSL for writing event stream monitors.</p><div class="fullcomment"><div class="comment cmt"><p>Daut (Data automata) is an internal Scala DSL for writing event stream monitors. It
supports flavors of state machines, temporal logic, and rule-based programming, all in one
unified formalism. The underlying concept is that at any point during monitoring there is an
active set of states, the _state soup_. States can be added and removed from this soup.
Each state in the soup either monitors the incoming event stream, or is used by other states to record
data (as in rule-based programming).</p><p>The specification language specifically supports:</p><ul><li>Automata, represented by states, parameterized with data (thereby the name Daut: Data automata).</li><li>Temporal operators which generate states, resulting in more succinct specifications.</li><li>Rule-based programming in that one can test for the presence of states and one can add states.</li><li>General purpose programming in Scala when the other specification features fall short.</li></ul><p>The DSL is a simplification of the TraceContract (<a href="https://github.com/havelund/tracecontract" target="_blank">https://github.com/havelund/tracecontract</a>) internal Scala DSL by an order of magnitude less code.</p><p>The general idea is to create a monitor as a class sub-classing the <code>Monitor</code> class,
create an instance of it, and then feed it with events with the <code>verify(event: Event)</code> method,
one by one, and in the case of a finite sequence of observations, finally calling the
<code>end()</code> method on it. If <code>end()</code> is called, it will be determined whether
there are any outstanding obligations that have not been satisfied (expected events that did not occur).</p><p>This can schematically be illustrated as follows:</p><pre><span class="kw">class</span> MyMonitor <span class="kw">extends</span> Monitor[SomeType] {
...
}

<span class="kw">object</span> Main {
  <span class="kw">def</span> main(args: <span class="std">Array</span>[<span class="std">String</span>]) {
    <span class="kw">val</span> m = <span class="kw">new</span> MyMonitor()
    m.verify(event1)
    m.verify(event2)
    ...
    m.verify(eventN)
    m.end()
  }
}</pre></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="current-entities indented1"><span class="separator"></span> <a href="Abstract.html" title="This monitor class provides methods for performing abstraction in addition to performing verification." class="class"></a><a href="Abstract.html" title="This monitor class provides methods for performing abstraction in addition to performing verification.">Abstract</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="DautOptions$.html" title="Daut options to be set by the user." class="object"></a><a href="DautOptions$.html" title="Daut options to be set by the user.">DautOptions</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="Monitor.html" title="Any monitor must sub-class this class." class="class"></a><a href="Monitor.html" title="Any monitor must sub-class this class.">Monitor</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="MonitorError.html" title="If the STOP_ON_ERROR flag is set to true, a MonitorError exception is thrown if a monitor's specification is violated by the observed event stream." class="class"></a><a href="MonitorError.html" title="If the STOP_ON_ERROR flag is set to true, a MonitorError exception is thrown if a monitor's specification is violated by the observed event stream.">MonitorError</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="" title="This monitor class provides methods for performing abstraction in addition to performing verification." class="class"></a><a href="" title="This monitor class provides methods for performing abstraction in addition to performing verification.">Translate</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="Util$.html" title="Utilities." class="object"></a><a href="Util$.html" title="Utilities.">Util</a></li></ul></div></div><div id="content"><body class="class type"><div id="definition"><div class="big-circle class">c</div><p id="owner"><a href="index.html" name="daut" id="daut" class="extype">daut</a></p><h1>Translate<span class="permalink"><a href="../daut/Translate.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><span class="name">Translate</span><span class="tparams">[<span name="E1">E1</span>, <span name="E2">E2</span>]</span><span class="result"> extends <a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a>[<span name="daut.Translate.E1" class="extype">E1</span>]</span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>This monitor class provides methods for performing abstraction in addition
to performing verification. The result of a verification is a new trace.
</p></div><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a>[<span name="daut.Translate.E1" class="extype">E1</span>], <span name="scala.AnyRef" class="extype">AnyRef</span>, <span name="scala.Any" class="extype">Any</span></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="daut.Translate"><span>Translate</span></li><li class="in" name="daut.Monitor"><span>Monitor</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="constructors" class="members"><h3>Instance Constructors</h3><ol><li class="indented0 " name="daut.Translate#&lt;init&gt;" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="&lt;init&gt;():daut.Translate[E1,E2]"></a><a id="&lt;init&gt;:Translate[E1,E2]"></a> <span class="permalink"><a href="../daut/Translate.html#&lt;init&gt;():daut.Translate[E1,E2]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">new</span></span> <span class="symbol"><span class="name">Translate</span><span class="params">()</span></span><p class="shortcomment cmt"></p></li></ol></div><div id="types" class="types members"><h3>Type Members</h3><ol><li class="indented0 " name="daut.Monitor.anonymous" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="prt"><a id="anonymousextendsMonitor.this.state"></a><a id="anonymous:anonymous"></a> <span class="permalink"><a href="../daut/Monitor.html#anonymousextendsMonitor.this.state" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Monitor$anonymous.html" title="An anonymous state can be labelled with data with a call of the label method."><span class="name">anonymous</span></a><span class="result"> extends <a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a></span></span><p class="shortcomment cmt">An anonymous state can be labelled with data with a call of the <code>label</code>
method.</p><div class="fullcomment"><div class="comment cmt"><p>An anonymous state can be labelled with data with a call of the <code>label</code>
method. The label becomes part of the result of calling the <code>toString</code>
method.
</p></div><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor.during" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="duringextendsMonitor.this.statewithProductwithSerializable"></a><a id="during:during"></a> <span class="permalink"><a href="../daut/Monitor.html#duringextendsMonitor.this.statewithProductwithSerializable" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="Monitor$during.html" title="The state is usually assigned to a local val-variable that can be queried e.g."><span class="name">during</span></a><span class="params">(<span name="es1">es1: <span name="daut.Monitor.E" class="extype">E</span>*</span>)</span><span class="params">(<span name="es2">es2: <span name="daut.Monitor.E" class="extype">E</span>*</span>)</span><span class="result"> extends <a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a> with <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">The state is usually assigned to a local <code>val</code>-variable that can be queried
e.g.</p><div class="fullcomment"><div class="comment cmt"><p>The state is usually assigned to a local <code>val</code>-variable that can be queried
e.g. in invariants, either simply using the during state as a Boolean (the state is lifted to a Booelean
with an implicit function) or by using the ==&gt; method. Consider the following
example illustrating a monitor that checks that at most one of two threads 1 and 2
are in a critical section at any time, using an invariant. A thread <code>x</code> can enter a critical
section with the <code>enter(x)</code> call, and leave with either an <code>exit(x)</code> call or an
<code>abort(x)</code> call.</p><pre><span class="kw">class</span> CriticalSectionMonitor <span class="kw">extends</span> Monitor[Event] {
  <span class="kw">val</span> critical1 = during(enter(<span class="num">1</span>))(exit(<span class="num">1</span>), abort(<span class="num">1</span>))
  <span class="kw">val</span> critical2 = during(enter(<span class="num">2</span>))(exit(<span class="num">2</span>), abort(<span class="num">1</span>))

  invariant {
    !(critical1 &amp;&amp; critical2)
  }
}</pre><p>The invariant can also be written as follows, using the ==&gt; method:</p><pre>invariant {
  critical1 =<span class="kw">=&gt;</span> !critical2
}</pre></div><dl class="paramcmts block"><dt class="param">es1</dt><dd class="cmt"><p>any of these events starts an interval.</p></dd><dt class="param">es2</dt><dd class="cmt"><p>any of these events ends an interval.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor.fact" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="prt"><a id="factextendsMonitor.this.state"></a><a id="fact:fact"></a> <span class="permalink"><a href="../daut/Monitor.html#factextendsMonitor.this.state" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Monitor$fact.html" title="A subtrait of the state trait."><span class="name">fact</span></a><span class="result"> extends <a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a></span></span><p class="shortcomment cmt">A subtrait of the <code>state</code> trait.</p><div class="fullcomment"><div class="comment cmt"><p>A subtrait of the <code>state</code> trait. Named states introduced by the user as case classes are called
facts and must extend this trait, as in:</p><pre><span class="kw">case</span> <span class="kw">class</span> MyData(x:<span class="std">Int</span>) <span class="kw">extends</span> fact</pre><p>The <code>toString</code> method works as for case classes.
</p></div><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor.state" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="prt"><a id="stateextendsAnyRef"></a><a id="state:state"></a> <span class="permalink"><a href="../daut/Monitor.html#stateextendsAnyRef" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Monitor$state.html" title="A state of the monitor."><span class="name">state</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">A state of the monitor.</p><div class="fullcomment"><div class="comment cmt"><p>A state of the monitor.
</p></div><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor.Transitions" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="Transitions=PartialFunction[E,Set[Monitor.this.state]]"></a><a id="Transitions:Transitions"></a> <span class="permalink"><a href="../daut/Translate.html#Transitions=PartialFunction[E,Set[Monitor.this.state]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">type</span></span> <span class="symbol"><span class="name">Transitions</span><span class="result alias"> = <span name="scala.PartialFunction" class="extype">PartialFunction</span>[<span name="daut.Translate.E1" class="extype">E1</span>, <span name="scala.Predef.Set" class="extype">Set</span>[<a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a>]]</span></span><p class="shortcomment cmt">The type of the partial function from events to sets of states representing
the transitions out of a state.</p><div class="fullcomment"><div class="comment cmt"><p>The type of the partial function from events to sets of states representing
the transitions out of a state. Note that a state transition can result in more
than one state: all resulting states will subsequently be explored in parallel,
and all must be satisfied by the subsequent sequence of events.
</p></div><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="daut.Monitor.error" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="error"></a><a id="error:Monitor.error"></a> <span class="permalink"><a href="../daut/Monitor.html#error" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Monitor$error$.html" title="Special state indicating a specification violation."><span class="name">error</span></a><span class="result"> extends <a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a> with <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">Special state indicating a specification violation.</p><div class="fullcomment"><div class="comment cmt"><p>Special state indicating a specification violation.
</p></div><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor.ok" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="ok"></a><a id="ok:ok"></a> <span class="permalink"><a href="../daut/Monitor.html#ok" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Monitor$ok$.html" title="Special state indicating successful termination."><span class="name">ok</span></a><span class="result"> extends <a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a> with <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">Special state indicating successful termination.</p><div class="fullcomment"><div class="comment cmt"><p>Special state indicating successful termination.
</p></div><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor.stay" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="stay"></a><a id="stay:stay"></a> <span class="permalink"><a href="../daut/Monitor.html#stay" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Monitor$stay$.html" title="Special state indicating that we stay in the current state."><span class="name">stay</span></a><span class="result"> extends <a href="Monitor$state.html" name="daut.Monitor.state" id="daut.Monitor.state" class="extype">state</a> with <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">Special state indicating that we stay in the current state.</p><div class="fullcomment"><div class="comment cmt"><p>Special state indicating that we stay in the current state. This is normally
achieved by none of the transitions being able to fire. However, there can be
situations where we want to provide a transition explicitly, to indicate that
we stay in the current state.
</p></div><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a> <span class="permalink"><a href="../daut/Translate.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##():Int"></a> <span class="permalink"><a href="../daut/Translate.html###():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a> <span class="permalink"><a href="../daut/Translate.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="daut.Monitor#STOP_ON_ERROR" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="STOP_ON_ERROR:Boolean"></a> <span class="permalink"><a href="../daut/Translate.html#STOP_ON_ERROR:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">var</span></span> <span class="symbol"><span class="name">STOP_ON_ERROR</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><p class="shortcomment cmt">Option, which when set to true will cause monitoring to stop the first time
a specification violation is encountered.</p><div class="fullcomment"><div class="comment cmt"><p>Option, which when set to true will cause monitoring to stop the first time
a specification violation is encountered. Otherwise monitoring will continue.
Default value is false.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#always" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="always(ts:Monitor.this.Transitions):Monitor.this.anonymous"></a><a id="always(Transitions):anonymous"></a> <span class="permalink"><a href="../daut/Translate.html#always(ts:Monitor.this.Transitions):Monitor.this.anonymous" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">always</span><span class="params">(<span name="ts">ts: <a href="#Transitions=PartialFunction[E,Set[Monitor.this.state]]" name="daut.Translate.Transitions" id="daut.Translate.Transitions" class="extmbr">Transitions</a></span>)</span><span class="result">: <a href="#anonymousextendsMonitor.this.state" name="daut.Monitor.anonymous" id="daut.Monitor.anonymous" class="extmbr">anonymous</a></span></span><p class="shortcomment cmt">Returns an always-state, where the transition function is the transition function provided,
modified to always include the state in the resulting state set of any transition.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an always-state, where the transition function is the transition function provided,
modified to always include the state in the resulting state set of any transition.
This corresponds to a state where the monitor is always waiting  until an event
is submitted that makes a transition fire, and where the state has a true
self loop, no matter what transition fires. The state is final.
</p></div><dl class="paramcmts block"><dt class="param">ts</dt><dd class="cmt"><p>the transition function.</p></dd><dt>returns</dt><dd class="cmt"><p>an anonymous always-state.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#apply" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="apply(events:List[E]):Monitor.this.type"></a><a id="apply(List[E1]):Translate.this.type"></a> <span class="permalink"><a href="../daut/Translate.html#apply(events:List[E]):Monitor.this.type" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">apply</span><span class="params">(<span name="events">events: <span name="scala.List" class="extype">List</span>[<span name="daut.Translate.E1" class="extype">E1</span>]</span>)</span><span class="result">: <a href="" name="daut.Translate" id="daut.Translate" class="extype">Translate</a>.this.type</span></span><p class="shortcomment cmt">Allows applying a monitor <code>M</code> to an event trace <code>t</code>, as follows: <code>M(t)</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Allows applying a monitor <code>M</code> to an event trace <code>t</code>, as follows: <code>M(t)</code>.
This has the same meaning as the longer <code>M.verify(t)</code>.
</p></div><dl class="paramcmts block"><dt class="param">events</dt><dd class="cmt"><p>list (trace) of events to verify.</p></dd><dt>returns</dt><dd class="cmt"><p>this monitor (allowing method chaining).</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#apply" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="apply(event:E):Monitor.this.type"></a><a id="apply(E1):Translate.this.type"></a> <span class="permalink"><a href="../daut/Translate.html#apply(event:E):Monitor.this.type" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">apply</span><span class="params">(<span name="event">event: <span name="daut.Translate.E1" class="extype">E1</span></span>)</span><span class="result">: <a href="" name="daut.Translate" id="daut.Translate" class="extype">Translate</a>.this.type</span></span><p class="shortcomment cmt">Allows applying a monitor <code>M</code> to an event <code>e</code>, as follows: <code>M(e)</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Allows applying a monitor <code>M</code> to an event <code>e</code>, as follows: <code>M(e)</code>.
This has the same meaning as the longer <code>M.verify(e)</code>.
</p></div><dl class="paramcmts block"><dt class="param">event</dt><dd class="cmt"><p>the submitted event to be verified.</p></dd><dt>returns</dt><dd class="cmt"><p>this monitor (allowing method chaining).</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0"></a> <span class="permalink"><a href="../daut/Translate.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="daut.Monitor#callBack" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="callBack():Unit"></a> <span class="permalink"><a href="../daut/Translate.html#callBack():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">callBack</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">This method is called when the monitor encounters an error, be it a safety
error or a liveness error.</p><div class="fullcomment"><div class="comment cmt"><p>This method is called when the monitor encounters an error, be it a safety
error or a liveness error.
It can be overridden by user. Its body is by default empty.
</p></div><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#check" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="check(b:Boolean,e:String):Unit"></a><a id="check(Boolean,String):Unit"></a> <span class="permalink"><a href="../daut/Translate.html#check(b:Boolean,e:String):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">check</span><span class="params">(<span name="b">b: <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="e">e: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">Checks whether the condition <code>b</code> is true, and if not, reports an error
on standard out.</p><div class="fullcomment"><div class="comment cmt"><p>Checks whether the condition <code>b</code> is true, and if not, reports an error
on standard out. The text message <code>e</code> becomes part of the error
message.
</p></div><dl class="paramcmts block"><dt class="param">b</dt><dd class="cmt"><p>the Boolean condition to be checked.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#check" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="check(b:Boolean):Unit"></a><a id="check(Boolean):Unit"></a> <span class="permalink"><a href="../daut/Translate.html#check(b:Boolean):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">check</span><span class="params">(<span name="b">b: <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">Checks whether the condition <code>b</code> is true, and if not, reports an error
on standard out.</p><div class="fullcomment"><div class="comment cmt"><p>Checks whether the condition <code>b</code> is true, and if not, reports an error
on standard out.
</p></div><dl class="paramcmts block"><dt class="param">b</dt><dd class="cmt"><p>the Boolean condition to be checked.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object"></a><a id="clone():AnyRef"></a> <span class="permalink"><a href="../daut/Translate.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<a href="../java/lang/index.html" name="java.lang" id="java.lang" class="extype">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="daut.Monitor#conStateSet2AndStateSet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="conStateSet2AndStateSet(set:Set[Monitor.this.state]):AnyRef{def&amp;(s:Monitor.this.state):Set[Monitor.this.state]}"></a><a id="conStateSet2AndStateSet(Set[state]):AnyRef{def&amp;(s:Translate.this.state):Set[Translate.this.state]}"></a> <span class="permalink"><a href="../daut/Translate.html#conStateSet2AndStateSet(set:Set[Monitor.this.state]):AnyRef{def&amp;(s:Monitor.this.state):Set[Monitor.this.state]}" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">conStateSet2AndStateSet</span><span class="params">(<span name="set">set: <span name="scala.Predef.Set" class="extype">Set</span>[<a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a>]</span>)</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span> { def &amp;(s: Translate.this.state): Set[Translate.this.state] }</span></span><p class="shortcomment cmt">Implicit function lifting a set of states to an anonymous object defining the <code>&amp;</code>-operator,
which defines conjunction of states.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit function lifting a set of states to an anonymous object defining the <code>&amp;</code>-operator,
which defines conjunction of states. Hence one can write <code>state1 &amp; state2 &amp; state3</code>, which then
results in the set <code>Set(state1,state2,state3)</code>. This works by first lifting
<code>state1 &amp; state2</code> to the set <code>Set(state1,state2)</code>, and then apply <code>&amp; state3</code> to
obtain <code>Set(state1,state2,state3)</code>.
</p></div><dl class="paramcmts block"><dt class="param">set</dt><dd class="cmt"><p>the set of states to be lifted.</p></dd><dt>returns</dt><dd class="cmt"><p>the anonymous object defining the method <code>&amp;(s2: state): Set[state]</code>.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#conTriple2StateSet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="conTriple2StateSet(states:(Monitor.this.state,Monitor.this.state,Monitor.this.state)):Set[Monitor.this.state]"></a><a id="conTriple2StateSet((state,state,state)):Set[state]"></a> <span class="permalink"><a href="../daut/Translate.html#conTriple2StateSet(states:(Monitor.this.state,Monitor.this.state,Monitor.this.state)):Set[Monitor.this.state]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">conTriple2StateSet</span><span class="params">(<span name="states">states: (<a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a>, <a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a>, <a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a>)</span>)</span><span class="result">: <span name="scala.Predef.Set" class="extype">Set</span>[<a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a>]</span></span><p class="shortcomment cmt">Implicit function lifting a 3-tuple of states to the set of those states.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit function lifting a 3-tuple of states to the set of those states.
This allows the more succinct notation <code>(state1,state2,state3)</code> instead of
<code>Set(state1,state2,state3)</code>.
</p></div><dl class="paramcmts block"><dt class="param">states</dt><dd class="cmt"><p>the 3-tuple of states to be lifted.</p></dd><dt>returns</dt><dd class="cmt"><p>the set containing the three states.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#conTuple2StateSet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="conTuple2StateSet(states:(Monitor.this.state,Monitor.this.state)):Set[Monitor.this.state]"></a><a id="conTuple2StateSet((state,state)):Set[state]"></a> <span class="permalink"><a href="../daut/Translate.html#conTuple2StateSet(states:(Monitor.this.state,Monitor.this.state)):Set[Monitor.this.state]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">conTuple2StateSet</span><span class="params">(<span name="states">states: (<a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a>, <a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a>)</span>)</span><span class="result">: <span name="scala.Predef.Set" class="extype">Set</span>[<a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a>]</span></span><p class="shortcomment cmt">Implicit function lifting a 2-tuple of states to the set of those states.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit function lifting a 2-tuple of states to the set of those states.
This allows the more succinct notation <code>(state1,state2)</code> instead of
<code>Set(state1,state2)</code>.
</p></div><dl class="paramcmts block"><dt class="param">states</dt><dd class="cmt"><p>the 2-tuple of states to be lifted.</p></dd><dt>returns</dt><dd class="cmt"><p>the set containing the two states.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#convBoolean2StateSet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="convBoolean2StateSet(b:Boolean):Set[Monitor.this.state]"></a><a id="convBoolean2StateSet(Boolean):Set[state]"></a> <span class="permalink"><a href="../daut/Translate.html#convBoolean2StateSet(b:Boolean):Set[Monitor.this.state]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">convBoolean2StateSet</span><span class="params">(<span name="b">b: <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.Predef.Set" class="extype">Set</span>[<a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a>]</span></span><p class="shortcomment cmt">Implicit function lifting a Boolean value <code>b</code> to the state set <code>Set(ok)</code>
if <code>b</code> is true, and to <code>Set(error)</code> if <code>b</code> is false.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit function lifting a Boolean value <code>b</code> to the state set <code>Set(ok)</code>
if <code>b</code> is true, and to <code>Set(error)</code> if <code>b</code> is false.
</p></div><dl class="paramcmts block"><dt class="param">b</dt><dd class="cmt"><p>the Boolean to be lifted.</p></dd><dt>returns</dt><dd class="cmt"><p>if  <code>b</code> then <code>Set(ok)</code> else <code>Set(error)</code>.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#convList2StateSet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="convList2StateSet(states:List[Monitor.this.state]):Set[Monitor.this.state]"></a><a id="convList2StateSet(List[state]):Set[state]"></a> <span class="permalink"><a href="../daut/Translate.html#convList2StateSet(states:List[Monitor.this.state]):Set[Monitor.this.state]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">convList2StateSet</span><span class="params">(<span name="states">states: <span name="scala.List" class="extype">List</span>[<a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a>]</span>)</span><span class="result">: <span name="scala.Predef.Set" class="extype">Set</span>[<a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a>]</span></span><p class="shortcomment cmt">Implicit function lifting a list of states to a set of states.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit function lifting a list of states to a set of states. This allows to
write the result of a transition e.g. as a for-yield construct, as in the following
result of a transition, which is a list of hot-states.</p><pre>always {
  <span class="kw">case</span> StopAll(someList) <span class="kw">=&gt;</span> <span class="kw">for</span> (x <span class="kw">&lt;-</span> someList) <span class="kw">yield</span> hot {<span class="kw">case</span> Stop(x) <span class="kw">=&gt;</span> ok}
}</pre></div><dl class="paramcmts block"><dt class="param">states</dt><dd class="cmt"><p>the list of states to be lifted.</p></dd><dt>returns</dt><dd class="cmt"><p>the set containing those states.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#convState2AndState" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="convState2AndState(s1:Monitor.this.state):AnyRef{def&amp;(s2:Monitor.this.state):Set[Monitor.this.state]}"></a><a id="convState2AndState(state):AnyRef{def&amp;(s2:Translate.this.state):Set[Translate.this.state]}"></a> <span class="permalink"><a href="../daut/Translate.html#convState2AndState(s1:Monitor.this.state):AnyRef{def&amp;(s2:Monitor.this.state):Set[Monitor.this.state]}" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">convState2AndState</span><span class="params">(<span name="s1">s1: <a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a></span>)</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span> { def &amp;(s2: Translate.this.state): Set[Translate.this.state] }</span></span><p class="shortcomment cmt">Implicit function lifting a state to an anonymous object defining the <code>&amp;</code>-operator,
which defines conjunction of states.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit function lifting a state to an anonymous object defining the <code>&amp;</code>-operator,
which defines conjunction of states. Hence one can write <code>state1 &amp; state2</code>, which then
results in the set <code>Set(state1,state2)</code>.
</p></div><dl class="paramcmts block"><dt class="param">s1</dt><dd class="cmt"><p>the state to be lifted.</p></dd><dt>returns</dt><dd class="cmt"><p>the anonymous object defining the method <code>&amp;(s2: state): Set[state]</code>.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#convState2Boolean" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="convState2Boolean(s:Monitor.this.state):Boolean"></a><a id="convState2Boolean(state):Boolean"></a> <span class="permalink"><a href="../daut/Translate.html#convState2Boolean(s:Monitor.this.state):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">convState2Boolean</span><span class="params">(<span name="s">s: <a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><p class="shortcomment cmt">Implicit function lifting a state to a Boolean, which is true iff.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit function lifting a state to a Boolean, which is true iff. the state
is amongst the current states. Hence, if <code>s</code> is a state then one can e.g.
write an expression (denoting a state) of the form:</p><pre><span class="kw">if</span> (s) error <span class="kw">else</span> ok</pre></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>the state to be lifted.</p></dd><dt>returns</dt><dd class="cmt"><p>true iff. the state <code>s</code> is amongst the current states.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#convState2StateSet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="convState2StateSet(state:Monitor.this.state):Set[Monitor.this.state]"></a><a id="convState2StateSet(state):Set[state]"></a> <span class="permalink"><a href="../daut/Translate.html#convState2StateSet(state:Monitor.this.state):Set[Monitor.this.state]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">convState2StateSet</span><span class="params">(<span name="state">state: <a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a></span>)</span><span class="result">: <span name="scala.Predef.Set" class="extype">Set</span>[<a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a>]</span></span><p class="shortcomment cmt">Implicit function converting a state to the a singleton state containing that state,
Recall that the result of a transition is a set of states.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit function converting a state to the a singleton state containing that state,
Recall that the result of a transition is a set of states. This function allows
to write a single state as result of a transition. That is e.g. <code>ok</code> instead
of <code>Set(ok)</code>.
</p></div><dl class="paramcmts block"><dt class="param">state</dt><dd class="cmt"><p>the state to be lifted.</p></dd><dt>returns</dt><dd class="cmt"><p>the singleton set <code>Set(state</code>.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#convUnit2StateSet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="convUnit2StateSet(u:Unit):Set[Monitor.this.state]"></a><a id="convUnit2StateSet(Unit):Set[state]"></a> <span class="permalink"><a href="../daut/Translate.html#convUnit2StateSet(u:Unit):Set[Monitor.this.state]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">convUnit2StateSet</span><span class="params">(<span name="u">u: <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="result">: <span name="scala.Predef.Set" class="extype">Set</span>[<a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a>]</span></span><p class="shortcomment cmt">Implicit function lifting the <code>Unit</code> value <code>()</code> to the set:
<code>Set(ok)</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit function lifting the <code>Unit</code> value <code>()</code> to the set:
<code>Set(ok)</code>. This allows to write code with side-effects (and return value
of type <code>Unit</code>) as a result of a transition.
</p></div><dl class="paramcmts block"><dt class="param">u</dt><dd class="cmt"><p>the Unit value to be lifted.</p></dd><dt>returns</dt><dd class="cmt"><p>the state set <code>Set(ok)</code>.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#end" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="end():Monitor.this.type"></a><a id="end():Translate.this.type"></a> <span class="permalink"><a href="../daut/Translate.html#end():Monitor.this.type" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">end</span><span class="params">()</span><span class="result">: <a href="" name="daut.Translate" id="daut.Translate" class="extype">Translate</a>.this.type</span></span><p class="shortcomment cmt">Ends the monitoring, reporting on all remaining current non-final states.</p><div class="fullcomment"><div class="comment cmt"><p>Ends the monitoring, reporting on all remaining current non-final states.
These represent obligations that have not been fulfilled.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>this monitor (allowing method chaining).</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#ensure" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="ensure(b:Boolean):Monitor.this.state"></a><a id="ensure(Boolean):state"></a> <span class="permalink"><a href="../daut/Translate.html#ensure(b:Boolean):Monitor.this.state" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ensure</span><span class="params">(<span name="b">b: <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a></span></span><p class="shortcomment cmt">Returns the state <code>ok</code> if the Boolean expression <code>b</code> is true, otherwise
it returns the <code>error</code> state.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the state <code>ok</code> if the Boolean expression <code>b</code> is true, otherwise
it returns the <code>error</code> state. The mothod can for example be used as the
result of a transition.
</p></div><dl class="paramcmts block"><dt class="param">b</dt><dd class="cmt"><p>Boolean condition.</p></dd><dt>returns</dt><dd class="cmt"><p>one of the states <code>ok</code> or <code>error</code>, depending on the value of <code>b</code>.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a> <span class="permalink"><a href="../daut/Translate.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#equals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="equals(x$1:Object):Boolean"></a><a id="equals(AnyRef):Boolean"></a> <span class="permalink"><a href="../daut/Translate.html#equals(x$1:Object):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="daut.Monitor#error" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="error(msg:String):Monitor.this.state"></a><a id="error(String):state"></a> <span class="permalink"><a href="../daut/Translate.html#error(msg:String):Monitor.this.state" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">error</span><span class="params">(<span name="msg">msg: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a></span></span><p class="shortcomment cmt">Returns an <code>error</code> state indicating a specification violation.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an <code>error</code> state indicating a specification violation.
</p></div><dl class="paramcmts block"><dt class="param">msg</dt><dd class="cmt"><p>message to be printed on standard out.</p></dd><dt>returns</dt><dd class="cmt"><p>the <code>error</code> state.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#exists" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="exists(pred:PartialFunction[Monitor.this.state,Boolean]):Boolean"></a><a id="exists(PartialFunction[state,Boolean]):Boolean"></a> <span class="permalink"><a href="../daut/Translate.html#exists(pred:PartialFunction[Monitor.this.state,Boolean]):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">exists</span><span class="params">(<span name="pred">pred: <span name="scala.PartialFunction" class="extype">PartialFunction</span>[<a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a>, <span name="scala.Boolean" class="extype">Boolean</span>]</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><p class="shortcomment cmt">Checks whether there exists an active state which satisfies the partial function
predicate provided as argument.</p><div class="fullcomment"><div class="comment cmt"><p>Checks whether there exists an active state which satisfies the partial function
predicate provided as argument. That is: where the partial function is defined on
the state, and returns true. The method is used for rule-based programming.
</p></div><dl class="paramcmts block"><dt class="param">pred</dt><dd class="cmt"><p>the partial function predicate tested on active states.</p></dd><dt>returns</dt><dd class="cmt"><p>true iff there exists an active state <code>s</code> such that <code>pred.isDefinedAt(s)</code>
        and <code>pred(s) == true</code>.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit"></a> <span class="permalink"><a href="../daut/Translate.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<a href="../java/lang/index.html" name="java.lang" id="java.lang" class="extype">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="daut.Monitor#getAllStates" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getAllStates:Set[Monitor.this.state]"></a><a id="getAllStates:Set[state]"></a> <span class="permalink"><a href="../daut/Translate.html#getAllStates:Set[Monitor.this.state]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getAllStates</span><span class="result">: <span name="scala.Predef.Set" class="extype">Set</span>[<a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a>]</span></span><p class="shortcomment cmt">Returns all states (facts) contained in the monitor.</p><div class="fullcomment"><div class="comment cmt"><p>Returns all states (facts) contained in the monitor.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>all states.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]"></a><a id="getClass():Class[_&lt;:AnyRef]"></a> <span class="permalink"><a href="../daut/Translate.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <span name="java.lang.Class" class="extype">Class</span>[_ &lt;: <span name="scala.AnyRef" class="extype">AnyRef</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="daut.Monitor#getErrorCount" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getErrorCount:Int"></a> <span class="permalink"><a href="../daut/Translate.html#getErrorCount:Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getErrorCount</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><p class="shortcomment cmt">Returns the number of errors detected by the monitor, its sub-monitors, their sub-monitors.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of errors detected by the monitor, its sub-monitors, their sub-monitors.
etc.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the number of errors of the monitor and its sub-monitors.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#hashCode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hashCode():Int"></a> <span class="permalink"><a href="../daut/Translate.html#hashCode():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="daut.Monitor#hot" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="hot(ts:Monitor.this.Transitions):Monitor.this.anonymous"></a><a id="hot(Transitions):anonymous"></a> <span class="permalink"><a href="../daut/Translate.html#hot(ts:Monitor.this.Transitions):Monitor.this.anonymous" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hot</span><span class="params">(<span name="ts">ts: <a href="#Transitions=PartialFunction[E,Set[Monitor.this.state]]" name="daut.Translate.Transitions" id="daut.Translate.Transitions" class="extmbr">Transitions</a></span>)</span><span class="result">: <a href="#anonymousextendsMonitor.this.state" name="daut.Monitor.anonymous" id="daut.Monitor.anonymous" class="extmbr">anonymous</a></span></span><p class="shortcomment cmt">Returns a hot-state, where the transition function is the transition function provided.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a hot-state, where the transition function is the transition function provided.
This corresponds to a state where the monitor is just waiting (watching) until an event
is submitted that makes a transition fire. The state is non-final, meaning
that it is an error to be in this state on a call of the <code>end()</code> method.
</p></div><dl class="paramcmts block"><dt class="param">ts</dt><dd class="cmt"><p>the transition function.</p></dd><dt>returns</dt><dd class="cmt"><p>an anonymous hot-state.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#initial" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="initial(s:Monitor.this.state):Unit"></a><a id="initial(state):Unit"></a> <span class="permalink"><a href="../daut/Translate.html#initial(s:Monitor.this.state):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">initial</span><span class="params">(<span name="s">s: <a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">Adds the argument state <code>s</code> to the set of initial states of the monitor.</p><div class="fullcomment"><div class="comment cmt"><p>Adds the argument state <code>s</code> to the set of initial states of the monitor.
</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>state to be added as initial state.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#invariant" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="invariant(e:String)(inv:=&gt;Boolean):Unit"></a><a id="invariant(String)(=&gt;Boolean):Unit"></a> <span class="permalink"><a href="../daut/Translate.html#invariant(e:String)(inv:=&gt;Boolean):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">invariant</span><span class="params">(<span name="e">e: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="params">(<span name="inv">inv: =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">Invariant method which takes an invariant Boolean valued expression (call by name)
as argument and adds the corresponding lambda abstraction (argument of type <code>Unit</code>)
to the list of invariants to check after each submission of an event.</p><div class="fullcomment"><div class="comment cmt"><p>Invariant method which takes an invariant Boolean valued expression (call by name)
as argument and adds the corresponding lambda abstraction (argument of type <code>Unit</code>)
to the list of invariants to check after each submission of an event. The first argument
is a message that will be printed in case the invariant is violated.
</p></div><dl class="paramcmts block"><dt class="param">e</dt><dd class="cmt"><p>message to be printed in case of an invariant violation.</p></dd><dt class="param">inv</dt><dd class="cmt"><p>the invariant expression to be checked after each submitted event.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#invariant" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="invariant(inv:=&gt;Boolean):Unit"></a><a id="invariant(=&gt;Boolean):Unit"></a> <span class="permalink"><a href="../daut/Translate.html#invariant(inv:=&gt;Boolean):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">invariant</span><span class="params">(<span name="inv">inv: =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">Invariant method which takes an invariant Boolean valued expression (call by name)
as argument and adds the corresponding lambda abstraction (argument of type <code>Unit</code>)
to the list of invariants to check after each submission of an event.</p><div class="fullcomment"><div class="comment cmt"><p>Invariant method which takes an invariant Boolean valued expression (call by name)
as argument and adds the corresponding lambda abstraction (argument of type <code>Unit</code>)
to the list of invariants to check after each submission of an event.
</p></div><dl class="paramcmts block"><dt class="param">inv</dt><dd class="cmt"><p>the invariant expression to be checked after each submitted event.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean"></a> <span class="permalink"><a href="../daut/Translate.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="daut.Monitor#keyOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="keyOf(event:E):Option[Any]"></a><a id="keyOf(E1):Option[Any]"></a> <span class="permalink"><a href="../daut/Translate.html#keyOf(event:E):Option[Any]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">keyOf</span><span class="params">(<span name="event">event: <span name="daut.Translate.E1" class="extype">E1</span></span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Any" class="extype">Any</span>]</span></span><p class="shortcomment cmt">Computes the key for an event.</p><div class="fullcomment"><div class="comment cmt"><p>Computes the key for an event. Keys are used for optimizing monitoring.
The method has a default definition returning <code>None</code> for all events. It
can be overridden by the user. Care should be taken since it interferes
with how properties are monitored.
</p></div><dl class="paramcmts block"><dt class="param">event</dt><dd class="cmt"><p>the event.</p></dd><dt>returns</dt><dd class="cmt"><p>the key computed for the event.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#liftBoolean" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="liftBoolean(p:Boolean):AnyRef{def==&gt;(q:Boolean):Boolean}"></a><a id="liftBoolean(Boolean):AnyRef{def==&gt;(q:Boolean):Boolean}"></a> <span class="permalink"><a href="../daut/Translate.html#liftBoolean(p:Boolean):AnyRef{def==&gt;(q:Boolean):Boolean}" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">liftBoolean</span><span class="params">(<span name="p">p: <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span> { def ==&gt;(q: Boolean): Boolean }</span></span><p class="shortcomment cmt">Implicit function lifting a Boolean to an anonymous object defining the implication
operator.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit function lifting a Boolean to an anonymous object defining the implication
operator. This allows to write <code>b1 ==&gt; b2</code> for two Boolean expressions
<code>b1</code> and <code>b2</code>. It has the same meaning as <code>!b1 || b2</code>.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>the Boolean to be lifted.</p></dd><dt>returns</dt><dd class="cmt"><p>the anonymous object defining the method <code>==&gt;(q: Boolean)</code>.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#liftInterval" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="liftInterval(iv:Monitor.this.during):Boolean"></a><a id="liftInterval(during):Boolean"></a> <span class="permalink"><a href="../daut/Translate.html#liftInterval(iv:Monitor.this.during):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">implicit </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">liftInterval</span><span class="params">(<span name="iv">iv: <a href="#duringextendsMonitor.this.statewithProductwithSerializable" name="daut.Monitor.during" id="daut.Monitor.during" class="extmbr">during</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><p class="shortcomment cmt">This function lifts a during-state to a Boolean value, true iff.</p><div class="fullcomment"><div class="comment cmt"><p>This function lifts a during-state to a Boolean value, true iff. the during-state is
within the interval.
</p></div><dl class="paramcmts block"><dt class="param">iv</dt><dd class="cmt"><p>the during-state to be lifted.</p></dd><dt>returns</dt><dd class="cmt"><p>true iff. the during-state <code>iv</code> is within the interval.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#map" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="map(pf:PartialFunction[Monitor.this.state,Set[Monitor.this.state]]):AnyRef{deforelse(otherwise:=&gt;Set[Monitor.this.state]):Set[Monitor.this.state]}"></a><a id="map(PartialFunction[state,Set[state]]):AnyRef{deforelse(otherwise:=&gt;Set[Translate.this.state]):Set[Translate.this.state]}"></a> <span class="permalink"><a href="../daut/Translate.html#map(pf:PartialFunction[Monitor.this.state,Set[Monitor.this.state]]):AnyRef{deforelse(otherwise:=&gt;Set[Monitor.this.state]):Set[Monitor.this.state]}" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">map</span><span class="params">(<span name="pf">pf: <span name="scala.PartialFunction" class="extype">PartialFunction</span>[<a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a>, <span name="scala.Predef.Set" class="extype">Set</span>[<a href="#stateextendsAnyRef" name="daut.Monitor.state" id="daut.Monitor.state" class="extmbr">state</a>]]</span>)</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span> { def orelse(otherwise: =&gt; Set[Translate.this.state]): Set[Translate.this.state] }</span></span><p class="shortcomment cmt">The <code>map</code> method returns a set of states computed as follows.</p><div class="fullcomment"><div class="comment cmt"><p>The <code>map</code> method returns a set of states computed as follows.
If the provided argument partial function <code>pf</code> is defined for any active states,
the resulting set is the union of all the state sets obtained by
applying the function to the active states for which it is defined.
Otherwise the returned set is the set <code>otherwise</code> provided as
argument to the <code>orelse</code> method.</p><p>As an example, consider the following monitor, which checks that
at most one task can acquire a lock at a time, and that
a task cannot release a lock it has not acquired.
This monitor illustrates the <code>map</code> function, which looks for stored
facts matching a pattern, and the ensure function, which checks a
condition (an assert). This function here in this example tests for
the presence of a Locked fact which is created when a lock is taken.</p><pre><span class="kw">trait</span> LockEvent
<span class="kw">case</span> <span class="kw">class</span> acquire(thread: <span class="std">Int</span>, lock: <span class="std">Int</span>) <span class="kw">extends</span> LockEvent
<span class="kw">case</span> <span class="kw">class</span> release(thread: <span class="std">Int</span>, lock: <span class="std">Int</span>) <span class="kw">extends</span> LockEvent

<span class="kw">class</span> OneAtATime <span class="kw">extends</span> Monitor[LockEvent] {
  <span class="kw">case</span> <span class="kw">class</span> Locked(thread: <span class="std">Int</span>, lock: <span class="std">Int</span>) <span class="kw">extends</span> state {
    watch {
      <span class="kw">case</span> release(thread, lock) <span class="kw">=&gt;</span> ok
    }
  }

  always {
    <span class="kw">case</span> acquire(t, l) <span class="kw">=&gt;</span> {
      map {
        <span class="kw">case</span> Locked(_,`l`) <span class="kw">=&gt;</span> error(<span class="lit">"allocated more than once"</span>)
      } orelse {
        Locked(t,l)
      }
    }
    <span class="kw">case</span> release(t, l) <span class="kw">=&gt;</span> ensure(Locked(t,l))
  }
}</pre><p>A more sophisticated example involving nested <code>map</code> calls is
the following that checks that when a task <code>t</code> is acquiring a
lock that some other task holds, and <code>t</code> therefore cannot get it,
then <code>t</code> is not allowed to hold any other locks (to prevent deadlocks).</p><pre><span class="kw">class</span> AvoidDeadlocks <span class="kw">extends</span> Monitor[LockEvent] {
  <span class="kw">case</span> <span class="kw">class</span> Locked(thread: <span class="std">Int</span>, lock: <span class="std">Int</span>) <span class="kw">extends</span> state {
    watch {
      <span class="kw">case</span> release(`thread`, `lock`) <span class="kw">=&gt;</span> ok
    }
  }

  always {
    <span class="kw">case</span> acquire(t, l) <span class="kw">=&gt;</span> {
      map {
        <span class="kw">case</span> Locked(_,`l`) <span class="kw">=&gt;</span>
          map {
            <span class="kw">case</span> Locked(`t`,x) <span class="kw">if</span> l != x <span class="kw">=&gt;</span> error
          } orelse {
            println(<span class="lit">"Can't lock but is not holding any other lock, so it's ok"</span>)
          }
      } orelse {
        Locked(t,l)
      }
    }
  }
}</pre></div><dl class="paramcmts block"><dt class="param">pf</dt><dd class="cmt"><p>partial function.</p></dd><dt>returns</dt><dd class="cmt"><p>set of states produced from applying the partial function <code>fp</code> to active states.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#monitor" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="monitor(monitors:daut.Monitor[E]*):Unit"></a><a id="monitor(Monitor[E1]*):Unit"></a> <span class="permalink"><a href="../daut/Translate.html#monitor(monitors:daut.Monitor[E]*):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">monitor</span><span class="params">(<span name="monitors">monitors: <a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a>[<span name="daut.Translate.E1" class="extype">E1</span>]*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">Launches the monitors provided as var-argument as sub-monitors of this monitor.</p><div class="fullcomment"><div class="comment cmt"><p>Launches the monitors provided as var-argument as sub-monitors of this monitor.
Being a sub-monitor has no special semantics, it is just a way of grouping
monitors in a hierarchical manner for organization purposes.
</p></div><dl class="paramcmts block"><dt class="param">monitors</dt><dd class="cmt"><p>the monitors to become sub-monitors of this monitor.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a> <span class="permalink"><a href="../daut/Translate.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="daut.Monitor#next" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="next(ts:Monitor.this.Transitions):Monitor.this.anonymous"></a><a id="next(Transitions):anonymous"></a> <span class="permalink"><a href="../daut/Translate.html#next(ts:Monitor.this.Transitions):Monitor.this.anonymous" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">next</span><span class="params">(<span name="ts">ts: <a href="#Transitions=PartialFunction[E,Set[Monitor.this.state]]" name="daut.Translate.Transitions" id="daut.Translate.Transitions" class="extmbr">Transitions</a></span>)</span><span class="result">: <a href="#anonymousextendsMonitor.this.state" name="daut.Monitor.anonymous" id="daut.Monitor.anonymous" class="extmbr">anonymous</a></span></span><p class="shortcomment cmt">Returns a next-state (strong next), where the transition function is the transition function provided,
modified to yield an error if it does not fire on the next submitted event.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a next-state (strong next), where the transition function is the transition function provided,
modified to yield an error if it does not fire on the next submitted event.
The transition is strong in the sense that a next event has to occur.
The state is therefore non-final.
</p></div><dl class="paramcmts block"><dt class="param">ts</dt><dd class="cmt"><p>the transition function.</p></dd><dt>returns</dt><dd class="cmt"><p>an anonymous next-state.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit"></a> <span class="permalink"><a href="../daut/Translate.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit"></a> <span class="permalink"><a href="../daut/Translate.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="daut.Translate#push" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="push(event:E2):Unit"></a><a id="push(E2):Unit"></a> <span class="permalink"><a href="../daut/Translate.html#push(event:E2):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">push</span><span class="params">(<span name="event">event: <span name="daut.Translate.E2" class="extype">E2</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">Adds event to the abstraction trace.</p><div class="fullcomment"><div class="comment cmt"><p>Adds event to the abstraction trace.
</p></div><dl class="paramcmts block"><dt class="param">event</dt><dd class="cmt"><p>event to be added to abstraction trace.</p></dd></dl></div></li><li class="indented0 " name="daut.Monitor#reportError" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="reportError(e:String):Unit"></a><a id="reportError(String):Unit"></a> <span class="permalink"><a href="../daut/Translate.html#reportError(e:String):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">reportError</span><span class="params">(<span name="e">e: <span name="scala.Predef.String" class="extype">String</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">Reports a detected error.</p><div class="fullcomment"><div class="comment cmt"><p>Reports a detected error.
</p></div><dl class="paramcmts block"><dt class="param">e</dt><dd class="cmt"><p>text string explaining the error. This will be printed as part of the
         error message.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#reportError" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="reportError():Unit"></a> <span class="permalink"><a href="../daut/Translate.html#reportError():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">reportError</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">Prints a very visible ERROR banner, in case <code>PRINT_ERROR_BANNER</code> is true.</p><div class="fullcomment"><div class="comment cmt"><p>Prints a very visible ERROR banner, in case <code>PRINT_ERROR_BANNER</code> is true.
Updates error count.
</p></div><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#stopOnError" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="stopOnError():daut.Monitor[E]"></a><a id="stopOnError():Monitor[E1]"></a> <span class="permalink"><a href="../daut/Translate.html#stopOnError():daut.Monitor[E]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">stopOnError</span><span class="params">()</span><span class="result">: <a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a>[<span name="daut.Translate.E1" class="extype">E1</span>]</span></span><p class="shortcomment cmt">A call of this method will cause the monitor and all its sub-monitors to stop on the first error encountered.</p><div class="fullcomment"><div class="comment cmt"><p>A call of this method will cause the monitor and all its sub-monitors to stop on the first error encountered.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the monitor itself so that the method can be called dot-appended to a constructor call.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](=&gt;T0):T0"></a> <span class="permalink"><a href="../daut/Translate.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String"></a> <span class="permalink"><a href="../daut/Translate.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <span name="java.lang.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="daut.Translate#trace" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="trace:List[E2]"></a> <span class="permalink"><a href="../daut/Translate.html#trace:List[E2]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">trace</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="daut.Translate.E2" class="extype">E2</span>]</span></span><p class="shortcomment cmt">Returns the produced abstraction.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the produced abstraction.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the abstraction.</p></dd></dl></div></li><li class="indented0 " name="daut.Monitor#unless" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="unless(ts1:Monitor.this.Transitions):Object{defwatch(ts2:Monitor.this.Transitions):Monitor.this.state}"></a><a id="unless(Transitions):AnyRef{defwatch(ts2:Translate.this.Transitions):Translate.this.state}"></a> <span class="permalink"><a href="../daut/Translate.html#unless(ts1:Monitor.this.Transitions):Object{defwatch(ts2:Monitor.this.Transitions):Monitor.this.state}" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">unless</span><span class="params">(<span name="ts1">ts1: <a href="#Transitions=PartialFunction[E,Set[Monitor.this.state]]" name="daut.Translate.Transitions" id="daut.Translate.Transitions" class="extmbr">Transitions</a></span>)</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span> { def watch(ts2: Translate.this.Transitions): Translate.this.state }</span></span><p class="shortcomment cmt">An expression of the form <code>unless {ts1} watch {ts2</code>} watches <code>ts2</code> repeatedly
unless <code>ts1</code> fires.</p><div class="fullcomment"><div class="comment cmt"><p>An expression of the form <code>unless {ts1} watch {ts2</code>} watches <code>ts2</code> repeatedly
unless <code>ts1</code> fires. That is, the expression returns an unless-state, where the transition function is
the combination of the two transition functions provided. The resulting transition function
first tries <code>ts1</code>, and if it can fire that is chosen. Otherwise <code>t2</code> is tried,
and if it can fire it is made to fire, and the unless-state is re-added to the resulting state set.
The transition function <code>ts1</code> does not need to ever fire, which makes the state final.
</p></div><dl class="paramcmts block"><dt class="param">ts1</dt><dd class="cmt"><p>the transition function.</p></dd><dt>returns</dt><dd class="cmt"><p>an anonymous unless-state.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#until" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="until(ts1:Monitor.this.Transitions):Object{defwatch(ts2:Monitor.this.Transitions):Monitor.this.state}"></a><a id="until(Transitions):AnyRef{defwatch(ts2:Translate.this.Transitions):Translate.this.state}"></a> <span class="permalink"><a href="../daut/Translate.html#until(ts1:Monitor.this.Transitions):Object{defwatch(ts2:Monitor.this.Transitions):Monitor.this.state}" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">until</span><span class="params">(<span name="ts1">ts1: <a href="#Transitions=PartialFunction[E,Set[Monitor.this.state]]" name="daut.Translate.Transitions" id="daut.Translate.Transitions" class="extmbr">Transitions</a></span>)</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span> { def watch(ts2: Translate.this.Transitions): Translate.this.state }</span></span><p class="shortcomment cmt">An expression of the form <code>until {ts1} watch {ts2</code>} watches <code>ts2</code> repeatedly
until <code>ts1</code> fires.</p><div class="fullcomment"><div class="comment cmt"><p>An expression of the form <code>until {ts1} watch {ts2</code>} watches <code>ts2</code> repeatedly
until <code>ts1</code> fires. That is, the expression returns an until-state, where the transition function is
the combination of the two transition functions provided. The resulting transition function
first tries <code>ts1</code>, and if it can fire that is chosen. Otherwise <code>t2</code> is tried,
and if it can fire it is made to fire, and the unless-state is re-added to the resulting state set.
The transition function <code>ts1</code> will need to eventually ever fire before <code>end()</code> is
called, which makes the state non-final.
</p></div><dl class="paramcmts block"><dt class="param">ts1</dt><dd class="cmt"><p>the transition function.</p></dd><dt>returns</dt><dd class="cmt"><p>an anonymous until-state.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#verify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="verify(event:E):Monitor.this.type"></a><a id="verify(E1):Translate.this.type"></a> <span class="permalink"><a href="../daut/Translate.html#verify(event:E):Monitor.this.type" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">verify</span><span class="params">(<span name="event">event: <span name="daut.Translate.E1" class="extype">E1</span></span>)</span><span class="result">: <a href="" name="daut.Translate" id="daut.Translate" class="extype">Translate</a>.this.type</span></span><p class="shortcomment cmt">Submits an event to the monitor for verification against the specification.</p><div class="fullcomment"><div class="comment cmt"><p>Submits an event to the monitor for verification against the specification.
The event is "submitted" to each relevant current state set (taking indexing into account),
each such application resulting in a new set of states.
The method evaluates the invariants as part of the verification.</p><p>The method uses indexing to optimize the monitoring: each event is mapped to
a key, which is used to fast-access the set of states relevant for the event.
</p></div><dl class="paramcmts block"><dt class="param">event</dt><dd class="cmt"><p>the submitted event.</p></dd><dt>returns</dt><dd class="cmt"><p>this monitor (allowing method chaining).</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#verify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="verify(events:List[E]):Monitor.this.type"></a><a id="verify(List[E1]):Translate.this.type"></a> <span class="permalink"><a href="../daut/Translate.html#verify(events:List[E]):Monitor.this.type" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">verify</span><span class="params">(<span name="events">events: <span name="scala.List" class="extype">List</span>[<span name="daut.Translate.E1" class="extype">E1</span>]</span>)</span><span class="result">: <a href="" name="daut.Translate" id="daut.Translate" class="extype">Translate</a>.this.type</span></span><p class="shortcomment cmt">Verifies a full trace of events.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies a full trace of events. For each event <code>e</code> it calls <code>verify(e)</code>. It calls <code>end()</code>
at the end of the trace.
</p></div><dl class="paramcmts block"><dt class="param">events</dt><dd class="cmt"><p>list (trace) of events to verify.</p></dd><dt>returns</dt><dd class="cmt"><p>this monitor (allowing method chaining).</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#verifyAfterEvent" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="verifyAfterEvent(event:E):Unit"></a><a id="verifyAfterEvent(E1):Unit"></a> <span class="permalink"><a href="../daut/Translate.html#verifyAfterEvent(event:E):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">verifyAfterEvent</span><span class="params">(<span name="event">event: <span name="daut.Translate.E1" class="extype">E1</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">This method is called <b>after</b> every call of <code>verify(event: E)</code>.</p><div class="fullcomment"><div class="comment cmt"><p>This method is called <b>after</b> every call of <code>verify(event: E)</code>.
It can be overridden by user. Its body is by default empty.
</p></div><dl class="paramcmts block"><dt class="param">event</dt><dd class="cmt"><p>the event being verified.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#verifyBeforeEvent" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="verifyBeforeEvent(event:E):Unit"></a><a id="verifyBeforeEvent(E1):Unit"></a> <span class="permalink"><a href="../daut/Translate.html#verifyBeforeEvent(event:E):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">verifyBeforeEvent</span><span class="params">(<span name="event">event: <span name="daut.Translate.E1" class="extype">E1</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">This method is called <b>before</b> every call of <code>verify(event: E)</code>.</p><div class="fullcomment"><div class="comment cmt"><p>This method is called <b>before</b> every call of <code>verify(event: E)</code>.
It can be overridden by user. Its body is by default empty.
</p></div><dl class="paramcmts block"><dt class="param">event</dt><dd class="cmt"><p>the event being verified.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit"></a> <span class="permalink"><a href="../daut/Translate.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a> <span class="permalink"><a href="../daut/Translate.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a> <span class="permalink"><a href="../daut/Translate.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="daut.Monitor#watch" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="watch(ts:Monitor.this.Transitions):Monitor.this.anonymous"></a><a id="watch(Transitions):anonymous"></a> <span class="permalink"><a href="../daut/Translate.html#watch(ts:Monitor.this.Transitions):Monitor.this.anonymous" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">watch</span><span class="params">(<span name="ts">ts: <a href="#Transitions=PartialFunction[E,Set[Monitor.this.state]]" name="daut.Translate.Transitions" id="daut.Translate.Transitions" class="extmbr">Transitions</a></span>)</span><span class="result">: <a href="#anonymousextendsMonitor.this.state" name="daut.Monitor.anonymous" id="daut.Monitor.anonymous" class="extmbr">anonymous</a></span></span><p class="shortcomment cmt">Returns a watch-state, where the transition function is exactly the transition function provided.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a watch-state, where the transition function is exactly the transition function provided.
This corresponds to a state where the monitor is just waiting (watching) until an event
is submitted that makes a transition fire. The state is final.
</p></div><dl class="paramcmts block"><dt class="param">ts</dt><dd class="cmt"><p>the transition function.</p></dd><dt>returns</dt><dd class="cmt"><p>an anonymous watch-state.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li><li class="indented0 " name="daut.Monitor#wnext" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="wnext(ts:Monitor.this.Transitions):Monitor.this.anonymous"></a><a id="wnext(Transitions):anonymous"></a> <span class="permalink"><a href="../daut/Translate.html#wnext(ts:Monitor.this.Transitions):Monitor.this.anonymous" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wnext</span><span class="params">(<span name="ts">ts: <a href="#Transitions=PartialFunction[E,Set[Monitor.this.state]]" name="daut.Translate.Transitions" id="daut.Translate.Transitions" class="extmbr">Transitions</a></span>)</span><span class="result">: <a href="#anonymousextendsMonitor.this.state" name="daut.Monitor.anonymous" id="daut.Monitor.anonymous" class="extmbr">anonymous</a></span></span><p class="shortcomment cmt">Returns a wnext-state (weak next), where the transition function is the transition function provided,
modified to yield an error if it does not fire on the next submitted event.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a wnext-state (weak next), where the transition function is the transition function provided,
modified to yield an error if it does not fire on the next submitted event.
The transition is weak in the sense that a next event does not have to occur (in contrast to strong next).
The state is therefore final.
</p></div><dl class="paramcmts block"><dt class="param">ts</dt><dd class="cmt"><p>the transition function.</p></dd><dt>returns</dt><dd class="cmt"><p>an anonymous wnext-state.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a></dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="daut.Monitor" class="parent"><h3>Inherited from <a href="Monitor.html" name="daut.Monitor" id="daut.Monitor" class="extype">Monitor</a>[<span name="daut.Translate.E1" class="extype">E1</span>]</h3></div><div name="scala.AnyRef" class="parent"><h3>Inherited from <span name="scala.AnyRef" class="extype">AnyRef</span></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
